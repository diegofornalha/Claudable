/**\n * Testes E2E para integraÃ§Ã£o completa do Sistema Enhanced\n * Valida integraÃ§Ã£o entre todos os componentes implementados\n */\n\nconst request = require('supertest');\nconst { Server } = require('socket.io');\nconst Client = require('socket.io-client');\nconst express = require('express');\nconst http = require('http');\n\n// Mock das dependÃªncias se necessÃ¡rio\njest.setTimeout(30000);\n\ndescribe('Enhanced System Integration E2E Tests', () => {\n  let app, server, io, clientSocket, serverUrl;\n\n  beforeAll(async () => {\n    // Setup test server\n    app = express();\n    server = http.createServer(app);\n    io = new Server(server, {\n      cors: { origin: '*', methods: ['GET', 'POST'] }\n    });\n    \n    app.use(express.json());\n    \n    // Start server on random port\n    const port = Math.floor(Math.random() * 10000) + 10000;\n    await new Promise((resolve) => {\n      server.listen(port, () => {\n        serverUrl = `http://localhost:${port}`;\n        resolve();\n      });\n    });\n    \n    console.log(`ðŸ§ª Test server running on ${serverUrl}`);\n  });\n\n  afterAll(async () => {\n    if (clientSocket) {\n      clientSocket.close();\n    }\n    if (server) {\n      await new Promise((resolve) => server.close(resolve));\n    }\n  });\n\n  beforeEach(async () => {\n    // Setup client socket for each test\n    clientSocket = Client(serverUrl);\n    await new Promise((resolve) => {\n      clientSocket.on('connect', resolve);\n    });\n  });\n\n  afterEach(() => {\n    if (clientSocket) {\n      clientSocket.close();\n    }\n  });\n\n  describe('Enhanced Agent Manager Integration', () => {\n    test('should handle enhanced agent registration and execution', async () => {\n      // Setup mock enhanced endpoints\n      app.get('/api/enhanced/status', (req, res) => {\n        res.json({\n          enabled: true,\n          agents: [\n            {\n              id: 'test-agent',\n              name: 'Test Agent',\n              capabilities: ['text_generation'],\n              isAvailable: true\n            }\n          ],\n          metrics: {\n            totalTasks: 10,\n            successfulTasks: 9,\n            avgResponseTime: 1500,\n            successRate: 0.9\n          }\n        });\n      });\n      \n      app.post('/api/enhanced/execute', (req, res) => {\n        const { task } = req.body;\n        \n        // Simulate task execution\n        setTimeout(() => {\n          res.json({\n            success: true,\n            result: {\n              success: true,\n              result: `Enhanced execution result for: ${task.content}`,\n              strategy: 'single_agent',\n              quality: {\n                passed: true,\n                overallScore: 8.5,\n                dimensions: {\n                  accuracy: 0.9,\n                  completeness: 0.85,\n                  clarity: 0.8,\n                  relevance: 0.9\n                }\n              },\n              duration: 1200\n            }\n          });\n        }, 100);\n      });\n      \n      // Test status endpoint\n      const statusResponse = await request(app)\n        .get('/api/enhanced/status')\n        .expect(200);\n      \n      expect(statusResponse.body.enabled).toBe(true);\n      expect(statusResponse.body.agents).toHaveLength(1);\n      expect(statusResponse.body.metrics.successRate).toBe(0.9);\n      \n      // Test task execution\n      const taskResponse = await request(app)\n        .post('/api/enhanced/execute')\n        .send({\n          task: {\n            content: 'Test task for enhanced execution',\n            type: 'text_generation',\n            priority: 'high'\n          },\n          options: {\n            maxRetries: 2\n          }\n        })\n        .expect(200);\n      \n      expect(taskResponse.body.success).toBe(true);\n      expect(taskResponse.body.result.success).toBe(true);\n      expect(taskResponse.body.result.quality.passed).toBe(true);\n      expect(taskResponse.body.result.quality.overallScore).toBeGreaterThan(8);\n    });\n  });\n\n  describe('Real-time Metrics Integration', () => {\n    test('should handle real-time metrics subscription and updates', (done) => {\n      // Setup mock metrics endpoint\n      app.get('/api/telemetry/metrics', (req, res) => {\n        res.json({\n          counters: {\n            totalRequests: 50,\n            successfulRequests: 47,\n            failedRequests: 3,\n            activeConnections: 5\n          },\n          health: {\n            successRate: 0.94,\n            status: 'healthy',\n            uptime: 3600\n          },\n          timestamp: Date.now()\n        });\n      });\n      \n      // Setup socket handlers for metrics\n      io.on('connection', (socket) => {\n        socket.on('metrics:subscribe', () => {\n          // Send initial metrics\n          socket.emit('metrics:initial', {\n            enhanced: {\n              totalTasks: 10,\n              successfulTasks: 9,\n              avgResponseTime: 1500,\n              successRate: 0.9\n            },\n            telemetry: {\n              counters: {\n                totalRequests: 50,\n                successfulRequests: 47\n              },\n              health: {\n                successRate: 0.94,\n                status: 'healthy'\n              }\n            },\n            timestamp: Date.now()\n          });\n          \n          // Simulate periodic updates\n          const interval = setInterval(() => {\n            socket.emit('metrics:update', {\n              enhanced: {\n                totalTasks: 11,\n                successfulTasks: 10,\n                avgResponseTime: 1400,\n                successRate: 0.91\n              },\n              timestamp: Date.now()\n            });\n          }, 1000);\n          \n          socket.on('disconnect', () => {\n            clearInterval(interval);\n          });\n        });\n      });\n      \n      // Test metrics subscription\n      clientSocket.emit('metrics:subscribe');\n      \n      let initialReceived = false;\n      let updateReceived = false;\n      \n      clientSocket.on('metrics:initial', (data) => {\n        expect(data.enhanced).toBeDefined();\n        expect(data.enhanced.successRate).toBe(0.9);\n        expect(data.telemetry).toBeDefined();\n        expect(data.telemetry.health.status).toBe('healthy');\n        initialReceived = true;\n        \n        if (updateReceived) {\n          done();\n        }\n      });\n      \n      clientSocket.on('metrics:update', (data) => {\n        expect(data.enhanced).toBeDefined();\n        expect(data.enhanced.successRate).toBe(0.91);\n        expect(data.timestamp).toBeDefined();\n        updateReceived = true;\n        \n        if (initialReceived) {\n          done();\n        }\n      });\n    });\n  });\n\n  describe('Structured Output Processing', () => {\n    test('should process and validate structured outputs', async () => {\n      // Setup structured output endpoints\n      app.get('/api/structured/schemas', (req, res) => {\n        res.json({\n          schemas: [\n            'complexity_analysis',\n            'task_decomposition',\n            'quality_evaluation',\n            'execution_result'\n          ],\n          count: 4\n        });\n      });\n      \n      app.post('/api/structured/process', (req, res) => {\n        const { data, schema } = req.body;\n        \n        // Simulate structured processing\n        if (schema === 'quality_evaluation') {\n          res.json({\n            success: true,\n            data: {\n              overallScore: data.overallScore,\n              dimensions: data.dimensions,\n              normalizedScore: data.overallScore / 10,\n              classification: data.overallScore >= 8 ? 'good' : 'acceptable',\n              improvementIndex: 0.2\n            },\n            schema: 'quality_evaluation',\n            metadata: {\n              processingTime: Date.now(),\n              validationPassed: true\n            }\n          });\n        } else {\n          res.status(400).json({\n            success: false,\n            error: 'Unsupported schema'\n          });\n        }\n      });\n      \n      // Test schema listing\n      const schemasResponse = await request(app)\n        .get('/api/structured/schemas')\n        .expect(200);\n      \n      expect(schemasResponse.body.schemas).toContain('quality_evaluation');\n      expect(schemasResponse.body.count).toBe(4);\n      \n      // Test structured processing\n      const processResponse = await request(app)\n        .post('/api/structured/process')\n        .send({\n          data: {\n            overallScore: 8.5,\n            dimensions: {\n              accuracy: 0.9,\n              completeness: 0.8,\n              clarity: 0.85,\n              relevance: 0.9\n            }\n          },\n          schema: 'quality_evaluation'\n        })\n        .expect(200);\n      \n      expect(processResponse.body.success).toBe(true);\n      expect(processResponse.body.data.normalizedScore).toBe(0.85);\n      expect(processResponse.body.data.classification).toBe('good');\n      expect(processResponse.body.metadata.validationPassed).toBe(true);\n    });\n  });\n\n  describe('Task Execution Integration', () => {\n    test('should handle complete task execution workflow', (done) => {\n      // Setup task execution socket handlers\n      io.on('connection', (socket) => {\n        socket.on('enhanced:execute_task', (data) => {\n          const { task, sessionId } = data;\n          \n          // Simulate task execution steps\n          setTimeout(() => {\n            socket.emit('enhanced:task_started', {\n              sessionId,\n              taskId: `task-${Date.now()}`,\n              timestamp: Date.now()\n            });\n          }, 100);\n          \n          setTimeout(() => {\n            socket.emit('quality:evaluation_complete', {\n              sessionId,\n              evaluation: {\n                overallScore: 8.2,\n                passed: true,\n                dimensions: {\n                  accuracy: 0.85,\n                  completeness: 0.8,\n                  clarity: 0.82,\n                  relevance: 0.85\n                }\n              },\n              timestamp: Date.now()\n            });\n          }, 200);\n          \n          setTimeout(() => {\n            socket.emit('enhanced:task_complete', {\n              sessionId,\n              result: {\n                success: true,\n                result: `Task completed: ${task.content}`,\n                strategy: 'single_agent',\n                quality: {\n                  passed: true,\n                  overallScore: 8.2\n                },\n                duration: 1800\n              },\n              timestamp: Date.now()\n            });\n          }, 300);\n        });\n      });\n      \n      // Test task execution\n      const testTask = {\n        content: 'Analyze this data and provide insights',\n        type: 'data_analysis',\n        priority: 'high'\n      };\n      \n      let taskStarted = false;\n      let qualityEvaluated = false;\n      let taskCompleted = false;\n      \n      clientSocket.on('enhanced:task_started', (data) => {\n        expect(data.taskId).toBeDefined();\n        expect(data.timestamp).toBeDefined();\n        taskStarted = true;\n        checkCompletion();\n      });\n      \n      clientSocket.on('quality:evaluation_complete', (data) => {\n        expect(data.evaluation.passed).toBe(true);\n        expect(data.evaluation.overallScore).toBeGreaterThan(8);\n        qualityEvaluated = true;\n        checkCompletion();\n      });\n      \n      clientSocket.on('enhanced:task_complete', (data) => {\n        expect(data.result.success).toBe(true);\n        expect(data.result.quality.passed).toBe(true);\n        expect(data.result.duration).toBeGreaterThan(0);\n        taskCompleted = true;\n        checkCompletion();\n      });\n      \n      function checkCompletion() {\n        if (taskStarted && qualityEvaluated && taskCompleted) {\n          done();\n        }\n      }\n      \n      // Execute task\n      clientSocket.emit('enhanced:execute_task', {\n        task: testTask,\n        sessionId: 'test-session',\n        options: {\n          maxRetries: 2\n        }\n      });\n    });\n  });\n\n  describe('Worker Pool Integration', () => {\n    test('should manage worker pool effectively', async () => {\n      // Setup worker pool endpoints\n      app.get('/api/workers/status', (req, res) => {\n        res.json({\n          totalWorkers: 5,\n          availableWorkers: 3,\n          busyWorkers: 2,\n          activeTasks: 2,\n          queuedTasks: 0,\n          metrics: {\n            totalTasks: 25,\n            completedTasks: 23,\n            failedTasks: 2,\n            avgExecutionTime: 2500\n          }\n        });\n      });\n      \n      app.get('/api/workers/metrics', (req, res) => {\n        res.json({\n          pool: {\n            totalTasks: 25,\n            completedTasks: 23,\n            failedTasks: 2,\n            avgExecutionTime: 2500\n          },\n          workers: [\n            {\n              id: 'worker-0',\n              status: 'available',\n              totalTasks: 5,\n              successRate: 1.0\n            },\n            {\n              id: 'worker-1',\n              status: 'busy',\n              totalTasks: 8,\n              successRate: 0.95\n            }\n          ],\n          utilization: 0.4,\n          timestamp: Date.now()\n        });\n      });\n      \n      // Test worker status\n      const statusResponse = await request(app)\n        .get('/api/workers/status')\n        .expect(200);\n      \n      expect(statusResponse.body.totalWorkers).toBe(5);\n      expect(statusResponse.body.availableWorkers).toBe(3);\n      expect(statusResponse.body.metrics.completedTasks).toBe(23);\n      \n      // Test worker metrics\n      const metricsResponse = await request(app)\n        .get('/api/workers/metrics')\n        .expect(200);\n      \n      expect(metricsResponse.body.workers).toHaveLength(2);\n      expect(metricsResponse.body.utilization).toBe(0.4);\n      expect(metricsResponse.body.pool.avgExecutionTime).toBe(2500);\n    });\n  });\n\n  describe('Quality Control Integration', () => {\n    test('should handle quality evaluation and feedback', async () => {\n      // Setup quality endpoints\n      app.post('/api/quality/evaluate', (req, res) => {\n        const { result, task } = req.body;\n        \n        // Simulate quality evaluation\n        res.json({\n          success: true,\n          evaluation: {\n            overallScore: 7.8,\n            dimensions: {\n              accuracy: 0.8,\n              completeness: 0.75,\n              clarity: 0.8,\n              relevance: 0.8\n            },\n            strengths: ['Clear structure', 'Good examples'],\n            weaknesses: ['Could be more detailed'],\n            confidence: 0.85,\n            passed: true\n          },\n          timestamp: Date.now()\n        });\n      });\n      \n      app.get('/api/quality/metrics', (req, res) => {\n        res.json({\n          totalEvaluations: 50,\n          averageScore: 8.1,\n          successRate: 0.92,\n          improvementTrend: 0.05,\n          currentThresholds: {\n            minimum: 0.7,\n            target: 0.85,\n            excellent: 0.95\n          }\n        });\n      });\n      \n      // Test quality evaluation\n      const evaluationResponse = await request(app)\n        .post('/api/quality/evaluate')\n        .send({\n          result: 'This is a test result to be evaluated',\n          task: {\n            content: 'Test task for quality evaluation',\n            type: 'text_generation'\n          }\n        })\n        .expect(200);\n      \n      expect(evaluationResponse.body.success).toBe(true);\n      expect(evaluationResponse.body.evaluation.passed).toBe(true);\n      expect(evaluationResponse.body.evaluation.overallScore).toBeGreaterThan(7);\n      expect(evaluationResponse.body.evaluation.confidence).toBeGreaterThan(0.8);\n      \n      // Test quality metrics\n      const metricsResponse = await request(app)\n        .get('/api/quality/metrics')\n        .expect(200);\n      \n      expect(metricsResponse.body.totalEvaluations).toBe(50);\n      expect(metricsResponse.body.successRate).toBe(0.92);\n      expect(metricsResponse.body.improvementTrend).toBe(0.05);\n    });\n  });\n\n  describe('End-to-End System Validation', () => {\n    test('should validate complete system integration', async () => {\n      // Test system health endpoint\n      app.get('/api/health', (req, res) => {\n        res.json({\n          status: 'healthy',\n          timestamp: Date.now(),\n          components: {\n            enhancedAgentManager: 'operational',\n            orchestratorService: 'operational',\n            qualityController: 'operational',\n            workerPool: 'operational',\n            telemetryMonitor: 'operational',\n            structuredOutputProcessor: 'operational'\n          },\n          metrics: {\n            totalRequests: 100,\n            successRate: 0.94,\n            avgResponseTime: 1500,\n            activeConnections: 5\n          }\n        });\n      });\n      \n      const healthResponse = await request(app)\n        .get('/api/health')\n        .expect(200);\n      \n      expect(healthResponse.body.status).toBe('healthy');\n      expect(healthResponse.body.components.enhancedAgentManager).toBe('operational');\n      expect(healthResponse.body.components.telemetryMonitor).toBe('operational');\n      expect(healthResponse.body.metrics.successRate).toBeGreaterThan(0.9);\n    });\n    \n    test('should handle concurrent operations', async () => {\n      // Setup concurrent endpoints\n      app.post('/api/concurrent/test', (req, res) => {\n        const { operations } = req.body;\n        \n        // Simulate concurrent processing\n        setTimeout(() => {\n          res.json({\n            success: true,\n            processed: operations.length,\n            results: operations.map((op, index) => ({\n              id: index,\n              operation: op,\n              status: 'completed',\n              duration: Math.random() * 1000 + 500\n            })),\n            totalDuration: Math.random() * 2000 + 1000\n          });\n        }, 200);\n      });\n      \n      const concurrentResponse = await request(app)\n        .post('/api/concurrent/test')\n        .send({\n          operations: [\n            'task_execution',\n            'quality_evaluation',\n            'metrics_collection',\n            'structured_processing'\n          ]\n        })\n        .expect(200);\n      \n      expect(concurrentResponse.body.success).toBe(true);\n      expect(concurrentResponse.body.processed).toBe(4);\n      expect(concurrentResponse.body.results).toHaveLength(4);\n      expect(concurrentResponse.body.totalDuration).toBeGreaterThan(1000);\n    });\n  });\n});"