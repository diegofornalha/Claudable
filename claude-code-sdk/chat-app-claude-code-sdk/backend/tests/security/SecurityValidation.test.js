/**\n * Testes de Validação de Segurança para Sistema Kingston Enhanced\n * Verifica autenticação, autorização, validação de entrada e proteção contra ataques\n */\n\nconst request = require('supertest');\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst helmet = require('helmet');\nconst validator = require('validator');\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\nconst { body, validationResult } = require('express-validator');\n\n// Mock app with security middleware\nconst app = express();\n\n// Security middleware\napp.use(helmet());\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: 'Too many requests from this IP',\n  standardHeaders: true,\n  legacyHeaders: false\n});\n\napp.use('/api/', limiter);\n\n// Mock JWT secret\nconst JWT_SECRET = 'test-secret-key-do-not-use-in-production';\n\n// Authentication middleware\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({ error: 'Access token required' });\n  }\n\n  jwt.verify(token, JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ error: 'Invalid or expired token' });\n    }\n    req.user = user;\n    next();\n  });\n};\n\n// Input validation middleware\nconst validateTaskInput = [\n  body('task.content')\n    .isLength({ min: 1, max: 10000 })\n    .withMessage('Task content must be between 1 and 10000 characters')\n    .custom((value) => {\n      // Prevent script injection\n      if (/<script[^>]*>.*?<\\/script>/gi.test(value)) {\n        throw new Error('Script tags are not allowed');\n      }\n      return true;\n    }),\n  body('task.type')\n    .isIn(['text_generation', 'data_analysis', 'code_generation', 'complex_analysis'])\n    .withMessage('Invalid task type'),\n  body('task.priority')\n    .optional()\n    .isIn(['low', 'normal', 'high', 'critical'])\n    .withMessage('Invalid priority level')\n];\n\n// Mock user database\nconst users = new Map();\nusers.set('admin', {\n  id: 'admin',\n  username: 'admin',\n  passwordHash: bcrypt.hashSync('admin123', 10),\n  role: 'admin',\n  permissions: ['read', 'write', 'admin']\n});\n\nusers.set('user', {\n  id: 'user',\n  username: 'user',\n  passwordHash: bcrypt.hashSync('user123', 10),\n  role: 'user',\n  permissions: ['read', 'write']\n});\n\nusers.set('readonly', {\n  id: 'readonly',\n  username: 'readonly',\n  passwordHash: bcrypt.hashSync('readonly123', 10),\n  role: 'readonly',\n  permissions: ['read']\n});\n\n// Authorization middleware\nconst requirePermission = (permission) => {\n  return (req, res, next) => {\n    if (!req.user || !req.user.permissions || !req.user.permissions.includes(permission)) {\n      return res.status(403).json({ error: `Permission required: ${permission}` });\n    }\n    next();\n  };\n};\n\n// Routes\napp.post('/api/auth/login', async (req, res) => {\n  const { username, password } = req.body;\n  \n  if (!username || !password) {\n    return res.status(400).json({ error: 'Username and password required' });\n  }\n  \n  const user = users.get(username);\n  if (!user || !bcrypt.compareSync(password, user.passwordHash)) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  \n  const token = jwt.sign(\n    { \n      id: user.id,\n      username: user.username,\n      role: user.role,\n      permissions: user.permissions\n    },\n    JWT_SECRET,\n    { expiresIn: '1h' }\n  );\n  \n  res.json({ token, user: { id: user.id, username: user.username, role: user.role } });\n});\n\napp.get('/api/health', (req, res) => {\n  res.json({ status: 'healthy', timestamp: Date.now() });\n});\n\napp.get('/api/enhanced/status', authenticateToken, requirePermission('read'), (req, res) => {\n  res.json({\n    enabled: true,\n    user: req.user.username,\n    metrics: {\n      totalTasks: 100,\n      successRate: 0.95\n    }\n  });\n});\n\napp.post('/api/enhanced/execute', \n  authenticateToken,\n  requirePermission('write'),\n  validateTaskInput,\n  (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    \n    const { task } = req.body;\n    \n    // Simulate task execution\n    res.json({\n      success: true,\n      result: {\n        success: true,\n        result: `Task executed by ${req.user.username}: ${task.content.substring(0, 50)}...`,\n        executedBy: req.user.id\n      }\n    });\n  }\n);\n\napp.delete('/api/enhanced/agents/:agentId',\n  authenticateToken,\n  requirePermission('admin'),\n  (req, res) => {\n    const { agentId } = req.params;\n    \n    // Validate agentId format\n    if (!validator.isAlphanumeric(agentId.replace(/-/g, ''))) {\n      return res.status(400).json({ error: 'Invalid agent ID format' });\n    }\n    \n    res.json({ success: true, message: `Agent ${agentId} deleted by ${req.user.username}` });\n  }\n);\n\n// File upload endpoint with security validation\napp.post('/api/upload',\n  authenticateToken,\n  requirePermission('write'),\n  (req, res) => {\n    // Simulate file upload validation\n    const contentType = req.headers['content-type'];\n    \n    // Check allowed content types\n    const allowedTypes = [\n      'text/plain',\n      'application/json',\n      'text/javascript',\n      'application/javascript'\n    ];\n    \n    if (!allowedTypes.some(type => contentType && contentType.includes(type))) {\n      return res.status(400).json({ error: 'File type not allowed' });\n    }\n    \n    res.json({ success: true, message: 'File uploaded successfully' });\n  }\n);\n\n// Admin-only endpoint\napp.get('/api/admin/users',\n  authenticateToken,\n  requirePermission('admin'),\n  (req, res) => {\n    const userList = Array.from(users.values()).map(user => ({\n      id: user.id,\n      username: user.username,\n      role: user.role\n    }));\n    \n    res.json({ users: userList });\n  }\n);\n\n// SQL Injection test endpoint (intentionally vulnerable for testing)\napp.get('/api/test/sql-injection', (req, res) => {\n  const { query } = req.query;\n  \n  // Simulate vulnerable SQL query\n  if (query && query.includes(\"'\")) {\n    return res.status(400).json({ error: 'Potential SQL injection detected' });\n  }\n  \n  res.json({ result: `Query executed: ${query}` });\n});\n\n// XSS test endpoint\napp.post('/api/test/xss', (req, res) => {\n  const { content } = req.body;\n  \n  // Check for XSS patterns\n  const xssPatterns = [\n    /<script[^>]*>.*?<\\/script>/gi,\n    /javascript:/gi,\n    /on\\w+\\s*=/gi,\n    /<iframe[^>]*>.*?<\\/iframe>/gi\n  ];\n  \n  const hasXSS = xssPatterns.some(pattern => pattern.test(content));\n  \n  if (hasXSS) {\n    return res.status(400).json({ error: 'Potential XSS content detected' });\n  }\n  \n  res.json({ sanitized: validator.escape(content) });\n});\n\n// Security tests\ndescribe('Kingston Enhanced System - Security Validation', () => {\n  describe('Authentication & Authorization', () => {\n    test('should require authentication for protected endpoints', async () => {\n      const response = await request(app)\n        .get('/api/enhanced/status')\n        .expect(401);\n        \n      expect(response.body.error).toBe('Access token required');\n    });\n\n    test('should authenticate valid users', async () => {\n      const loginResponse = await request(app)\n        .post('/api/auth/login')\n        .send({ username: 'admin', password: 'admin123' })\n        .expect(200);\n        \n      expect(loginResponse.body.token).toBeDefined();\n      expect(loginResponse.body.user.username).toBe('admin');\n      expect(loginResponse.body.user.role).toBe('admin');\n    });\n\n    test('should reject invalid credentials', async () => {\n      await request(app)\n        .post('/api/auth/login')\n        .send({ username: 'admin', password: 'wrongpassword' })\n        .expect(401);\n    });\n\n    test('should enforce role-based access control', async () => {\n      // Get readonly user token\n      const readonlyLogin = await request(app)\n        .post('/api/auth/login')\n        .send({ username: 'readonly', password: 'readonly123' })\n        .expect(200);\n        \n      // Try to access write endpoint\n      await request(app)\n        .post('/api/enhanced/execute')\n        .set('Authorization', `Bearer ${readonlyLogin.body.token}`)\n        .send({\n          task: {\n            content: 'Test task',\n            type: 'text_generation'\n          }\n        })\n        .expect(403);\n    });\n\n    test('should enforce admin-only access', async () => {\n      // Get regular user token\n      const userLogin = await request(app)\n        .post('/api/auth/login')\n        .send({ username: 'user', password: 'user123' })\n        .expect(200);\n        \n      // Try to access admin endpoint\n      await request(app)\n        .get('/api/admin/users')\n        .set('Authorization', `Bearer ${userLogin.body.token}`)\n        .expect(403);\n    });\n\n    test('should allow admin access to all endpoints', async () => {\n      // Get admin token\n      const adminLogin = await request(app)\n        .post('/api/auth/login')\n        .send({ username: 'admin', password: 'admin123' })\n        .expect(200);\n        \n      // Access admin endpoint\n      const response = await request(app)\n        .get('/api/admin/users')\n        .set('Authorization', `Bearer ${adminLogin.body.token}`)\n        .expect(200);\n        \n      expect(response.body.users).toBeDefined();\n      expect(Array.isArray(response.body.users)).toBe(true);\n    });\n  });\n\n  describe('Input Validation & Sanitization', () => {\n    let userToken;\n    \n    beforeAll(async () => {\n      const login = await request(app)\n        .post('/api/auth/login')\n        .send({ username: 'user', password: 'user123' });\n      userToken = login.body.token;\n    });\n\n    test('should validate task input parameters', async () => {\n      await request(app)\n        .post('/api/enhanced/execute')\n        .set('Authorization', `Bearer ${userToken}`)\n        .send({\n          task: {\n            content: '', // Empty content\n            type: 'invalid_type' // Invalid type\n          }\n        })\n        .expect(400);\n    });\n\n    test('should reject oversized input', async () => {\n      const largeContent = 'a'.repeat(10001); // Exceeds 10000 char limit\n      \n      await request(app)\n        .post('/api/enhanced/execute')\n        .set('Authorization', `Bearer ${userToken}`)\n        .send({\n          task: {\n            content: largeContent,\n            type: 'text_generation'\n          }\n        })\n        .expect(400);\n    });\n\n    test('should prevent script injection in task content', async () => {\n      await request(app)\n        .post('/api/enhanced/execute')\n        .set('Authorization', `Bearer ${userToken}`)\n        .send({\n          task: {\n            content: '<script>alert(\"xss\")</script>Malicious content',\n            type: 'text_generation'\n          }\n        })\n        .expect(400);\n    });\n\n    test('should validate agent ID format', async () => {\n      const adminLogin = await request(app)\n        .post('/api/auth/login')\n        .send({ username: 'admin', password: 'admin123' });\n        \n      await request(app)\n        .delete('/api/enhanced/agents/invalid<>id')\n        .set('Authorization', `Bearer ${adminLogin.body.token}`)\n        .expect(400);\n    });\n\n    test('should accept valid input', async () => {\n      const response = await request(app)\n        .post('/api/enhanced/execute')\n        .set('Authorization', `Bearer ${userToken}`)\n        .send({\n          task: {\n            content: 'This is a valid task content',\n            type: 'text_generation',\n            priority: 'normal'\n          }\n        })\n        .expect(200);\n        \n      expect(response.body.success).toBe(true);\n    });\n  });\n\n  describe('Rate Limiting & DoS Protection', () => {\n    test('should enforce rate limiting', async () => {\n      const requests = [];\n      \n      // Make 101 requests (1 more than limit)\n      for (let i = 0; i < 101; i++) {\n        requests.push(\n          request(app)\n            .get('/api/health')\n            .set('X-Forwarded-For', '192.168.1.100') // Simulate same IP\n        );\n      }\n      \n      const responses = await Promise.all(requests);\n      \n      // Some requests should be rate limited\n      const rateLimited = responses.filter(res => res.status === 429);\n      expect(rateLimited.length).toBeGreaterThan(0);\n    }, 10000);\n\n    test('should handle concurrent requests without crashing', async () => {\n      const concurrentRequests = Array.from({ length: 50 }, () => \n        request(app).get('/api/health')\n      );\n      \n      const responses = await Promise.all(concurrentRequests);\n      \n      // All responses should be successful or rate limited\n      responses.forEach(response => {\n        expect([200, 429]).toContain(response.status);\n      });\n    });\n  });\n\n  describe('Injection Attack Prevention', () => {\n    test('should prevent SQL injection attempts', async () => {\n      const sqlInjectionPayloads = [\n        \"'; DROP TABLE users; --\",\n        \"' OR '1'='1\",\n        \"' UNION SELECT * FROM users --\",\n        \"'; DELETE FROM users WHERE '1'='1\"\n      ];\n      \n      for (const payload of sqlInjectionPayloads) {\n        const response = await request(app)\n          .get('/api/test/sql-injection')\n          .query({ query: payload });\n          \n        expect(response.status).toBe(400);\n        expect(response.body.error).toContain('SQL injection');\n      }\n    });\n\n    test('should prevent XSS attacks', async () => {\n      const xssPayloads = [\n        '<script>alert(\"xss\")</script>',\n        '<img src=\"x\" onerror=\"alert(1)\">',\n        'javascript:alert(\"xss\")',\n        '<iframe src=\"javascript:alert(1)\"></iframe>'\n      ];\n      \n      for (const payload of xssPayloads) {\n        const response = await request(app)\n          .post('/api/test/xss')\n          .send({ content: payload });\n          \n        expect(response.status).toBe(400);\n        expect(response.body.error).toContain('XSS');\n      }\n    });\n\n    test('should sanitize safe content properly', async () => {\n      const safeContent = 'This is <b>bold</b> text with & symbols';\n      \n      const response = await request(app)\n        .post('/api/test/xss')\n        .send({ content: safeContent })\n        .expect(200);\n        \n      expect(response.body.sanitized).toBeDefined();\n      expect(response.body.sanitized).toContain('&lt;b&gt;');\n      expect(response.body.sanitized).toContain('&amp;');\n    });\n  });\n\n  describe('File Upload Security', () => {\n    let userToken;\n    \n    beforeAll(async () => {\n      const login = await request(app)\n        .post('/api/auth/login')\n        .send({ username: 'user', password: 'user123' });\n      userToken = login.body.token;\n    });\n\n    test('should allow safe file types', async () => {\n      await request(app)\n        .post('/api/upload')\n        .set('Authorization', `Bearer ${userToken}`)\n        .set('Content-Type', 'text/plain')\n        .send('Safe text content')\n        .expect(200);\n    });\n\n    test('should reject dangerous file types', async () => {\n      await request(app)\n        .post('/api/upload')\n        .set('Authorization', `Bearer ${userToken}`)\n        .set('Content-Type', 'application/x-executable')\n        .send('Executable content')\n        .expect(400);\n    });\n\n    test('should reject files without proper content type', async () => {\n      await request(app)\n        .post('/api/upload')\n        .set('Authorization', `Bearer ${userToken}`)\n        .send('Content without type')\n        .expect(400);\n    });\n  });\n\n  describe('JWT Token Security', () => {\n    test('should reject expired tokens', async () => {\n      // Create expired token\n      const expiredToken = jwt.sign(\n        { id: 'test', username: 'test' },\n        JWT_SECRET,\n        { expiresIn: '-1h' }\n      );\n      \n      await request(app)\n        .get('/api/enhanced/status')\n        .set('Authorization', `Bearer ${expiredToken}`)\n        .expect(403);\n    });\n\n    test('should reject malformed tokens', async () => {\n      await request(app)\n        .get('/api/enhanced/status')\n        .set('Authorization', 'Bearer invalid.token.here')\n        .expect(403);\n    });\n\n    test('should reject tokens with wrong signature', async () => {\n      const wrongToken = jwt.sign(\n        { id: 'test', username: 'test' },\n        'wrong-secret'\n      );\n      \n      await request(app)\n        .get('/api/enhanced/status')\n        .set('Authorization', `Bearer ${wrongToken}`)\n        .expect(403);\n    });\n  });\n\n  describe('Security Headers', () => {\n    test('should include security headers', async () => {\n      const response = await request(app)\n        .get('/api/health')\n        .expect(200);\n        \n      // Check for Helmet security headers\n      expect(response.headers['x-content-type-options']).toBe('nosniff');\n      expect(response.headers['x-frame-options']).toBeDefined();\n      expect(response.headers['x-xss-protection']).toBeDefined();\n    });\n\n    test('should not expose sensitive information in errors', async () => {\n      const response = await request(app)\n        .post('/api/auth/login')\n        .send({ username: 'nonexistent', password: 'password' })\n        .expect(401);\n        \n      // Should not reveal whether user exists\n      expect(response.body.error).toBe('Invalid credentials');\n      expect(response.body.error).not.toContain('user not found');\n      expect(response.body.error).not.toContain('password');\n    });\n  });\n\n  describe('HTTPS and Transport Security', () => {\n    test('should handle secure transport expectations', async () => {\n      // In production, this would test actual HTTPS\n      // For now, verify the app structure supports it\n      expect(app).toBeDefined();\n    });\n  });\n\n  describe('Data Privacy & GDPR Compliance', () => {\n    test('should not log sensitive data', () => {\n      // Verify that passwords and tokens are not logged\n      // This would be tested with actual logging in production\n      expect(true).toBe(true); // Placeholder\n    });\n\n    test('should handle user data deletion requests', () => {\n      // In production, implement actual GDPR compliance endpoints\n      expect(true).toBe(true); // Placeholder\n    });\n  });\n\n  describe('Security Monitoring & Alerting', () => {\n    test('should detect suspicious activity patterns', async () => {\n      // Simulate multiple failed login attempts\n      const failedAttempts = [];\n      \n      for (let i = 0; i < 5; i++) {\n        failedAttempts.push(\n          request(app)\n            .post('/api/auth/login')\n            .send({ username: 'admin', password: 'wrongpassword' })\n        );\n      }\n      \n      const responses = await Promise.all(failedAttempts);\n      \n      // All should fail\n      responses.forEach(response => {\n        expect(response.status).toBe(401);\n      });\n      \n      // In production, this would trigger security alerts\n    });\n\n    test('should monitor for unusual request patterns', async () => {\n      // Simulate rapid requests from single source\n      const rapidRequests = Array.from({ length: 20 }, () => \n        request(app)\n          .get('/api/health')\n          .set('X-Forwarded-For', '192.168.1.101')\n      );\n      \n      await Promise.all(rapidRequests);\n      \n      // In production, this would be flagged for review\n      expect(true).toBe(true); // Placeholder\n    });\n  });\n});"